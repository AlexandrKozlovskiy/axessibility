%% This is file `axessibility.sty',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% axessibility.dtx 
%% 
%% This is a generated file.
%% 
%% Copyright (C) 2018, 2019  by
%% Anna Capietto, Sandro Coriasco, Boris Doubrov, Alexander Kozlovskiy, Tiziana Armano,
%% Nadir Murru, Alice Ruighi, Eugenia Taranto,
%% Dragan Ahmetovic, Cristian Bernareggi, Michele Berra.
%% 
%% This work consists of the main source file axessibility.dtx
%% and the derived files
%%    axessibility.ins, axessibility.sty, axessibility.pdf, README,
%%    axessibilityExampleGoldenMean.tex
%% 
%% The Current Maintainer of this work is
%%                Sandro Coriasco
%% 
%% This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 License
%% http://creativecommons.org/licenses/by-nc/4.0/
%% 



\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{axessibility}

%% 'tagpdf' or 'accsupp' option
\newif\iftagpdfopt
%% 'mathml' option
\newif\ifmathmlopt
\DeclareOption{accsupp}{
  \tagpdfoptfalse}
\DeclareOption{tagpdf}{
  \tagpdfopttrue
}
\DeclareOption{mathml}{
  \mathmlopttrue}
  \ExecuteOptions{tagpdf}

\ProcessOptions\relax

\RequirePackage{amsmath}
\RequirePackage{amssymb}
\RequirePackage{xstring}

%%%
% to avoid errors in if constructs
%%%
\makeatletter
\long\def\@macronestedifalign{
\ifingather@
    \restorealignstate@
    \egroup
    \nonumber
    \ifnum0=`{\fi\iffalse}\fi
  \else
    $$%
  \fi
  }
  
\long\def\@macronestedifmultline{  
  \iftagsleft@ \@xp\lendmultline@ \else \@xp\rendmultline@ \fi
}
  
  
\makeatother

\iftagpdfopt
%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%
% tagpdf option code (default)   %
%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%
%\def\messaggio{option tagpdf} %debug
\RequirePackage{tagpdf}
\tagpdfsetup{tabsorder=structure,uncompress,activate-all,add-new-tag=Title/P,interwordspace=true}
%switch on expl3 syntaks for works with variables
\ExplSyntaxOn
\makeatletter
\tagpdfifpdftexT
 {
\usepackage[T1]{fontenc}
  \input glyphtounicode
  \pdfgentounicode=1

  \tl_new:N \g__last_mc_tl %last opened mc tag with all params
  \bool_new:N \g__inside_new_page_command_bool
\let\orig@newpage=\newpage
\cs_gset_eq:NN \orig@tagmcbegin \tagmcbegin
\cs_gset_eq:NN \orig@tagmcend \tagmcend
\cs_gset_protected:Npn \tagmcbegin #1{
\tl_gset:Nn \g__last_mc_tl{#1}
\orig@tagmcbegin{#1}
}
\cs_gset_protected:Npn \tagmcend{
\orig@tagmcend
\bool_if:NTF \g__inside_new_page_command_bool{}{\tl_gclear:N \g__last_mc_tl}
}
  \renewcommand{\newpage}{
  \tl_if_empty:NTF \g__last_mc_tl{
  \orig@newpage
}{
\bool_gset_true:N \g__inside_new_page_command_bool
\tagmcend
\bool_gset_false:N \g__inside_new_page_command_bool
\orig@newpage
\exp_args:No \tagmcbegin{\g__last_mc_tl}
}}
 }
\tagpdfifluatexT
 {
  \RequirePackage{luacode}
%\RequirePackage{fontspec}
  %\newfontface\zerowidthfont{freeserif}
\directlua{
require("axessibility.lua")
}
\ifmathmlopt
	\directlua{
eqn_types_filename_ids = {"_inl_", "_dsl_", "_dml_", "_ukn_"}~
			eqn_types="idmu"~
			eqn_ctrs = {0,0,0,0}~
	                 eqn_type_selector="u"
}
\fi
}

\newtoks\@mltext
\newtoks\@mltexttmp

%switch on or switch off $$ and $ replacement and replacement of empty lines if $$ or $ opened and if first argument of command is true. this command works only in luatex/lualatex
\newcommand{\doreplacement}[1]{
\sys_if_engine_luatex:TF{
\directlua{
replace_dls_and_double_dls(#1)
}}
{\PackageWarning{axessibility}{\detokenize{\doreplacement}~command~works~only~in~luatex/lualatex.}}
}
%variable,which shows,if we need in tagging of something,except document environment and formulas.
\bool_new:N{\g__autotagging_bool}
\bool_gset_true:N{\g__autotagging_bool}
\AtBeginDocument{
\cs_undefine:N{\noAutotagging}
\bool_if:NTF{\g__autotagging_bool}{\startautotagging}{}
\@ifpackageloaded{array}{ }
{
\cs_new_eq:NN \LTX@tabularcr \@tabularcr
\RenewDocumentCommand \@tabularcr { s o }
{
\g__tabular_cr:Nnn \LTX@tabularcr {#1} {#2} }
      }
    \cs_new_eq:NN \LTX@arraycr \@arraycr
    \RenewDocumentCommand \@arraycr { s o }
      { \g__tabular_cr:Nnn \LTX@arraycr {#1} {#2} }
}
\AtEndDocument{
%closing all open structures
\bool_if:NTF{\g__opened_par_bool}{\tagmcend}{}
\int_step_inline:nnn{2}{\seq_count:N \g__tag_struct_stack_seq}{\tagstructend}
\bool_gset_false:N\g__opened_par_bool
}
\newcommand{\CloseFormula}{
\tagmcend
\bool_if:NTF{\g__opened_par_bool}{
%now we close structure to,because even in inline formulas we open structure tag.
\tagstructend}{
\tagstructend
}
}
%command,which switch off tagging of all,except formula. It should be call only before \begin{document}
\newcommand{\noAutotagging}{\bool_gset_false:N{\g__autotagging_bool}
\message{command~\detokenize{\noautotagging}~will~be~unaccessible~anymore}
\cs_undefine:N{\noAutotagging}
}
%variable,which show,if we have opened paragraph
\bool_new:N\g__opened_par_bool
\protected\def\startautotagging{
%open tag Document
\tagstructbegin{tag=Document}
%variable,which shows,if we in some structure,eccept paragraph.
\bool_new:N\g__in_struct_bool
%variable,which show,if we in some environment,o no.
\str_new:N{\g__env_str}
%variable,which show level of list.
\int_gzero_new:N\g__list_level_int
\int_gzero_new:N \g__table_level_int
\seq_const_from_clist:Nn \g__level_variables_seq{\g__list_level_int,\g__table_level_int}
%property with environments,before and after which we will close and open mc/struct tags.
\prop_gset_from_keyval:Nn\g__env_prop{temp@env=false,equation=true,equation*=true,align=true,align*=true,flalign=true,flalign*=true,gather=true,gather*=true,multline=true,multline*=true,alignat=true,alignat*=true,xalignat=true,xalignat*=true,xxalignat=true,xxalignat*=true,description=1,description*=1,enumerate=1,enumerate*=1,itemize=1,itemize*=1,table=true,table*=true,tabular=1,tabular*=1}
\cs_generate_variant:Nn \prop_item:Nn { NV }
%close and open mc or structure in environments
\prop_map_inline:cn{g__env_prop}{
\BeforeBeginEnvironment{##1}{
\closeStructureIfNeed{##2}\str_case:nnF{##2}{{0}{}{1}{}}{
%when we in level 0 for each environment,we can close paragraph,if need.
\int_case:nnF{\int_eval:n{\seq_use:Nn \g__level_variables_seq{+}}}{{0}{
\new@everypar{}
\bool_gset_true:N\g__in_struct_bool
}}{}}
\str_gset:Nn{\g__env_str}{##1}}
\AfterEndEnvironment{##1}{
\str_case:nnF{##2}{{0}{}{1}{}}{
%when we in level 0 for each environment,we can open paragraph,if need.
\int_case:nnF{\int_eval:n{\seq_use:Nn \g__level_variables_seq{+}}}{{0}{
\bool_gset_false:N\g__in_struct_bool
\openStructureIfNeed{##2}
\new@everypar{\autoTaggingOfPar}
}
}
{}
}}}
\protected\def\openStructureIfNeed##1{
\bool_if:NTF{\g__in_struct_bool}{}{
\str_case:nnF {##1}{
{true}
{\bool_gset_true:N{\g__opened_par_bool}\tagstructbegin{tag=P}}
{1}
{\bool_gset_true:N\g__opened_par_bool\tagstructbegin{tag=P}}
}
{}
\tagmcbegin{tag=P}
\str_gclear:N{\g__env_str}
}}
\protected\def\closeStructureIfNeed##1{
\bool_if:NTF{\g__opened_par_bool}{
\tagmcend
\str_case:nnF {##1}{
{true}
{\bool_gset_false:N\g__opened_par_bool\tagstructend
}
{1}
{\bool_gset_false:N\g__opened_par_bool\tagstructend
}
}
{}
}
{
}
}
\protected\def\autoTaggingOfPar{
%\message{New~paragraph.~the~size~of~stack~of~structure~elements~is~\seq_count:N \g__tag_struct_stack_seq}
\closeStructureIfNeed{true}
\openStructureIfNeed{true}
}
%reassign token list \everypar,which should works for list
\let\old@everypar=\everypar
\newtoks{\everypar}
\newtoks{\new@everypar}
\old@everypar{\the\everypar\the\new@everypar}
\new@everypar{\autoTaggingOfPar}
%commands for sectioning
%ddictionary for sectioning
\prop_gset_from_keyval:Nn \g__sections_prop{chapter=H1,section=H2,subsection=H3,subsubsection=H4,paragraph=H5,subparagraph=H6,caption=Caption,emph=Span}
\prop_map_inline:Nn \g__sections_prop {
\cs_if_exist:cTF { ##1 }
   {
    \cs_set_eq:cc {orig@##1} {##1}
\exp_args:No \RenewDocumentCommand{\cs:w ##1 \cs_end:}{s o m}{
\bool_gset_true:N\g__in_struct_bool
\closeStructureIfNeed{true}
%\message{the_size_of_stack_of_structure_elements_before_opening_of_structure_is_\seq_count:N \g__tag_struct_stack_seq}     
	 \tagstructbegin{tag=##2}
            \tagmcbegin{tag=##2}
\use:x{
\exp_not:c {orig@##1}
\IfBooleanT {####1} { * }
\IfValueT {####2} { [####2]}
{####3}
}
\tagmcend
      \tagstructend
\bool_gset_false:N{\g__in_struct_bool}
\bool_gset_false:N\g__opened_par_bool
\new@everypar{\autoTaggingOfPar}
 }
}
{}
}
%\let\old@chapter=\chapter
%\let\old@section=\section
%\let\old@subsection=\subsection
%\let\old@subsubsection=\subsubsection
%\let\old@paragraph=\paragraph
%\let\old@subparagraph=\subparagraph
%do for \@author,\@date\@thanks and @\title the same,what we did for sections,subsections etc.
\prop_set_from_keyval:Nn \l__data_of_title_prop
  {
    @author = H1 ,
    @date   = H1 ,
    @title  = H1 ,
  }
%redefining \@thanks command for maketitle
%taked fromm https://tex.stackexchange.com/questions/527791/how-correctly-redefine-maketitle-to-add-tagged-elements-in-latex#527801
\DeclareRobustCommand\thanks[1]{\footnotemark
    \protected@xdef\@thanks{\@thanks
        \protect\footnotetext[\the\c@footnote]{
\tl_if_empty:NTF ##1{##1}{
\tagstructbegin{tag=H1}
\tagmcbegin{tag=H1}
##1
\tagmcend
\tagstructend
}
}}}
\cs_new_eq:NN \orig@maketitle \maketitle
\cs_gset_protected:Npn\maketitle{
\closeStructureIfNeed{true}
\bool_gset_true:N\g__in_struct_bool
\tagstructbegin{tag=Title}
\prop_map_inline:Nn \l__data_of_title_prop{
\cs_set_eq:cc { orig@####1 } { ####1 }
\tl_if_empty:cTF{####1}
{
\use:c { orig@####1 }
}
{
\cs_gset_protected:cpn { ####1 } {
\tagstructbegin{tag=####2}
\tagmcbegin{tag=####2}
\use:c { orig@####1 } 
\tagmcend
\tagstructend
}
}
}
\orig@maketitle
\tagstructend
\bool_gset_false:N\g__in_struct_bool
\bool_gset_false:N\g__opened_par_bool
\new@everypar{\autoTaggingOfPar}
\openStructureIfNeed{true}
}
%\ifdef{\chapter}{
%\renewcommand{\chapter}[1]{\closeStructureIfNeed{true}\tagstructbegin{tag=H1}\tagmcbegin{tag=H1}\old@chapter{##1}\tagmcend\tagstructend\new@everypar{\autoTaggingOfPar}}}
%\renewcommand{\section}[1]{\closeStructureIfNeed{true}\tagstructbegin{tag=H2}\tagmcbegin{tag=H2}\old@section{##1}\tagmcend\tagstructend\new@everypar{\autoTaggingOfPar}}
%\renewcommand{\subsection}[1]{\closeStructureIfNeed{true}\tagstructbegin{tag=H3}\tagmcbegin{tag=H3}\old@subsection{##1}\tagmcend\tagstructend\new@everypar{\autoTaggingOfPar}}
%\renewcommand{\subsubsection}[1]{\closeStructureIfNeed{true}\tagstructbegin{tag=H4}\tagmcbegin{tag=H4}\old@subsubsection{##1}\tagmcend\tagstructend\new@everypar{\autoTaggingOfPar}}
%\renewcommand{\paragraph}[1]{\closeStructureIfNeed{true}\tagstructbegin{tag=H5}\tagmcbegin{tag=H5}\old@paragraph{##1}\tagmcend\tagstructend\new@everypar{\autoTaggingOfPar}}
%\renewcommand{\subparagraph}[1]{\closeStructureIfNeed{true}\tagstructbegin{tag=H6}\tagmcbegin{tag=H6}\old@subparagraph{##1}\tagmcend\tagstructend\new@everypar{\autoTaggingOfPar}}
%prop for label commands.
\prop_gset_from_keyval:Nn \g__labels_prop{descriptionlabel=1,labelenumi=0,labelenumii=0,labelenumiii=0,labelenumiv=0,labelitemi=0,lablitemii=0,labelitemiii=0,labelitemiv=0}
\prop_map_inline:Nn \g__labels_prop{
\cs_set_eq:cc{orig@##1}{##1}
%set protected command depends of number of arguments,which you can see in \g__labels_prop. If we have one or more arguments,we check,if it an empty and if yes,we not tagging label.
\int_case:nnF{##2}{{0}{\cs_gset_protected:cpn { ##1 }
     {
\tagstructbegin{tag=LI}
\tagstructbegin{tag=Lbl}
\tagmcbegin{tag=Lbl}
\use:c { orig@##1 }
\tagmcend
\tagstructend
}}}
{\cs_gset_protected:cpn { ##1 }####1
     {
\tagstructbegin{tag=LI}
\tl_if_empty:NTF ####1 {\use:c { orig@##1 }####1}{\tagstructbegin{tag=Lbl}
\tagmcbegin{tag=Lbl}
\use:c { orig@##1 }####1
\tagmcend
\tagstructend
}
}
}
}
%prop for list environments. if we have 0 value,we redefine begin,1 - end.
\prop_gset_from_keyval:Nn{\g__lists_prop}{description=0,description*=0,enumerate=0,enumerate*=0,itemize=0,itemize*=0}
\prop_map_inline:Nn \g__lists_prop{
\AtBeginEnvironment{##1}{
\int_case:nnF{\g__list_level_int}{{0}{}}{
%we need check,if we have items in previous level,and if yes,close mc and struct before starting of the list.
\bool_if:cTF{g__first_item_\int_eval:n{\g__list_level_int}_bool}{\closeStructureIfNeed{true}
%We close previous LBody and LI
\tagstructend\tagstructend
}
{}
\tagstructbegin{tag=LI}
\tagstructbegin{tag=LBody}
}
\int_gincr:N{\g__list_level_int}
\bool_if_exist:cTF{g__first_item_\int_eval:n{\g__list_level_int}_bool}{}{\bool_new:c{g__first_item_\int_eval:n{\g__list_level_int}_bool}}
\tagstructbegin{tag=L}
}
\AtEndEnvironment{##1}{
\bool_if:cTF{g__first_item_\int_eval:n{\g__list_level_int}_bool}{
\closeStructureIfNeed{true}
\tagstructend
\tagstructend
\bool_gset_false:c{g__first_item_\int_eval:n{\g__list_level_int}_bool}
}
{
%if we haven't items,but we have level more then one,we have sublist before,so we should close LI and LBody.
\int_case:nnF{\g__list_level_int-1}{{0}{}}{\tagstructend\tagstructend}
}
\int_gdecr:N{\g__list_level_int}
\tagstructend
}
}
%now we redefine \item command,
\let\orig@item=\item
\renewcommand{\item}{
\bool_if_exist:cTF{g__first_item_\int_eval:n{\g__list_level_int}_bool}{
\bool_if:cTF{g__	first_item_\int_eval:n{\g__list_level_int}_bool}{\closeStructureIfNeed{true}\tagstructend\tagstructend}{
\bool_gset_true:c{g__first_item_\int_eval:n{\g__list_level_int}_bool}
}
\orig@item
\tagstructbegin{tag=LBody}
\openStructureIfNeed{true}
}
{
\orig@item}
}
%tagging of tables
%closing and opening of td/th
\newcommand{\closeAndOpenCellIfNeed}[1]{
\str_case:nnF{##1}{{1}{
\closeStructureIfNeed{true}
\tagstructend %closing of TD or TH
}{true}{
\closeStructureIfNeed{true}
\tagstructend %closing of TD or TH
}}
{}
\bool_if:cTF{g__first_line_\int_eval:n{\g__table_level_int}_bool}{
\tagstructbegin{tag=TD}
}
{
\tagstructbegin{tag=TH}
}
\openStructureIfNeed{true}
}
%reddefine new line depending of package. Thanks @phelype-oleinik (https://tex.stackexchange.com/questions/570112/how-to-redefine-command-inside-a-tabular-using-expl3)
\cs_new_protected:Npn \g__tabular_cr:Nnn ##1 ##2 ##3{
\use:x {
\exp_not:N ##1
\IfBooleanT {##2} { * } \IfValueT {##3} { [{##3}]}}
%to avoid issue with multicolumn,we should use \noalign,but it not works correct in luamode. Look at https://github.com/u-fischer/tagpdf/issues/36 for more details.
%\noalign {
\closeStructureIfNeed{true}
\tagstructend
\tagstructend
\bool_if:cTF{g__first_line_\int_eval:n{\g__table_level_int}_bool}{}
{
\tagstructend
\tagstructbegin{tag=TBody}
\bool_gset_true:c{g__first_line_\int_eval:n{\g__table_level_int}_bool}
}
\tagstructbegin{tag=TR}
\closeAndOpenCellIfNeed{false}
%}
}
%tagging of & char_set_active_eq
\cs_new_protected:Npn \g__tab_char: {

\closeAndOpenCellIfNeed{true}
}
%tagging of table environments
\prop_gset_from_keyval:Nn\g__table_prop{tabular=1,tabular*=1,tabbin=0,tabbing*=0}
\prop_map_inline:Nn \g__table_prop{
\AtBeginEnvironment{##1}{
\int_case:nnF{\g__table_level_int}{{0}
{
% Make active-& equal to the macro above, and make & active:
\int_case:nnF{##2}{{0}{}{1}{
\char_set_active_eq:NN \& \g__tab_char:
\char_set_catcode_active:N \&
}}{}
}
}
{
\closeStructureIfNeed{true}
\tagstructend\tagstructend
}
\int_gincr:N{\g__table_level_int}
\bool_if_exist:cTF{g__first_line_\int_eval:n{\g__table_level_int}_bool}{}{\bool_new:c{g__first_line_\int_eval:n{\g__table_level_int}_bool}}
\tagstructbegin{tag=Table}
\tagstructbegin{tag=THead}
\tagstructbegin{tag=TR}
\closeAndOpenCellIfNeed{false}
}
\AtEndEnvironment{##1}{
\closeStructureIfNeed{true}
\tagstructend
\tagstructend
\bool_gset_false:c{g__first_line_\int_eval:n{\g__table_level_int}_bool}
\int_gdecr:N{\g__table_level_int}
\int_case:nnF{\g__table_level_int}{{0}{
\tagstructend
\tagstructend
\int_case:nnF{##2}{{0}{}{1}{
\cs_undefine:N \l__tab_char:
\char_set_catcode_alignment:N \&
}}{}
}}{
%\tagstructbegin{tag=TR}
%\closeAndOpenCellIfNeed{true}
}
}
}
\let\orig@startfield=\@startfield
\let\orig@stopfield=\@stopfield
\let\orig@startline=\@startline
\let\orig@stopline=\@stopline
\renewcommand{\@startfield}
{
\int_case:nnF{\g__table_level_int}{{0}{}}{
\closeAndOpenCellIfNeed{false}
}
\orig@startfield
}
\renewcommand{\@stopfield}
{
\orig@stopfield
\int_case:nnF{\g__table_level_int}{{0}{}}{\closeStructureIfNeed{true}\tagstructend}
}
\renewcommand{\@startline}{
\int_case:nnF{\g__table_level_int}{{0}{}}{
%\bool_if_exist:cTF{g__first_line_\int_eval:n{\g__table_level_int}_bool}{}{\bool_new:c{g__first_line_\int_eval:n{\g__table_level_int}_bool}}
\tagstructbegin{tag=TR}
\closeAndOpenCellIfNeed{false}
}
\orig@startline}
\renewcommand{\@stopline}{
\int_case:nnF{\g__table_level_int}{{0}{}}{
\closestructureIfNeed{true}
\tagstructend
\tagstructend
\bool_if:cTF{g__first_line_\int_eval:n{\g__table_level_int}_bool}{}{\bool_gset_true:c{g__first_line_\int_eval:n{\g__table_level_int}_bool}\tagstructend\tagstructbegin{tag=TBody}}
}
\orig@stopline
}
%end of \startAutotagging command
}
\newenvironment{temp@env}{%
  \relax\ifmmode\@badmath\else$\fi%
 \collect@body\wrap}{%
\relax\ifmmode\ifinner$\else\@badmath\fi\else \@badmath\fi}
\protected\def\(#1\){
\tagpdfifluatexT{
\ifmathmlopt \directlua{
eqn_type_selector="i"
                                                   }
\fi
}
\begin{temp@env}#1\end{temp@env}}
\newcommand{\auxiliaryspace}{~}
\long\def\wrap#1{
\tagpdfifluatexT{  \ifmathmlopt \directlua{
execute_mathml_formula([[\detokenize\expandafter{#1}]],eqn_type_selector)
                                                   }
												   \fi }
\bool_if:NTF{\g__autotagging_bool}{
\str_case_e:nnTF{\prop_item:NV{\g__env_prop}{\g__env_str}}{
{true}
{\tagstructbegin{tag=P,alttext-o=\detokenize\expandafter{#1}}
\tagmcbegin{tag=P}
 #1
 \tagmcend
\tagstructend}
{1}
{\tagstructbegin{tag=P,alttext-o=\detokenize\expandafter{#1}}
 \tagmcbegin{tag=P}
 #1
 \tagmcend
\tagstructend}
}{}{\tagstructbegin{tag=Span,alttext-o=\detokenize\expandafter{#1}}
\tagmcbegin{tag=Span}
#1
 \tagmcend
 \tagstructend
}
}
{\tagstructbegin{tag=P,alttext-o=\detokenize\expandafter{#1}}
\tagmcbegin{tag=P}
 #1
 \tagmcend
\tagstructend}
}
\renewenvironment{equation}{%
\tagpdfifluatexT{  \ifmathmlopt \directlua{
						eqn_type_selector="d"
                                                   } \fi }
 \incr@eqnum
  \mathdisplay@push
  \st@rredfalse \global\@eqnswtrue
 \mathdisplay{equation}%
  \collect@body\wrap\auxiliaryspace}{%
  \endmathdisplay{equation}%
  \mathdisplay@pop
  \ignorespacesafterend
}
\renewenvironment{equation*}{%
\tagpdfifluatexT{  \ifmathmlopt \directlua{
						eqn_type_selector="d"
                                                   } \fi }
  \mathdisplay@push
  \st@rredtrue \global\@eqnswfalse
  \mathdisplay{equation*}%
  \collect@body\wrap\auxiliaryspace}{%
  \endmathdisplay{equation*}%
  \mathdisplay@pop
  \ignorespacesafterend
}
\protected\def\[#1\]{\begin{equation*}#1\end{equation*}}
\long\def\wrapml#1{
\def\@mltext{\detokenize\expandafter{#1}}
\def\@mltexttmp{}
\StrBehind[6]{\@mltext}{~}[\@mltexttmp]
\StrGobbleRight{\@mltexttmp}{1}[\@mltext]
\tagpdfifluatexT{  \ifmathmlopt \directlua{
execute_mathml_formula([[\detokenize\expandafter{#1}]],"m")
}
\fi }
\bool_if:NTF{\g__opened_par_bool}{\tagstructbegin{tag=Span,alttext-o=\detokenize\expandafter{\@mltext}}
\tagmcbegin{tag=Span,}
#1}
{\tagstructbegin{tag=P,alttext-o=\detokenize\expandafter{\@mltext}}
\tagmcbegin{tag=P}
#1}
}
%
% This one should be \wrapml parametrized \StrBehind[5]
%
\long\def\wrapmlstar#1{
\def\@mltext{\detokenize\expandafter{#1}}
\def\@mltexttmp{}
\StrBehind[5]{\@mltext}{~}[\@mltexttmp]
\StrGobbleRight{\@mltexttmp}{1}[\@mltext]
\tagpdfifluatexT{  \ifmathmlopt \directlua{
execute_mathml_formula([[\detokenize\expandafter{#1}]],"m")
}
\fi }
\bool_if:NTF{\g__opened_par_bool}{\tagstructbegin{tag=Span,alttext-o=\detokenize\expandafter{\@mltext}}
\tagmcbegin{tag=Span}
#1}{
\tagstructbegin{tag=P,alttext-o=\detokenize\expandafter{\@mltext}}
\tagmcbegin{tag=P}
#1
}
}
%
% This one should be \wrapml parametrized = \wrapmlstar
%
\long\def\wrapmlalt#1{
\def\@mltext{\detokenize\expandafter{#1}}
\def\@mltexttmp{}
\StrBehind[5]{\@mltext}{~}[\@mltexttmp]
\StrGobbleRight{\@mltexttmp}{1}[\@mltext]
\tagpdfifluatexT{  \ifmathmlopt \directlua{
execute_mathml_formula([[\detokenize\expandafter{#1}]],"m")
                                                   } \fi }
\bool_if:NTF{\g__opened_par_bool}{\tagstructbegin{tag=Span,alttext-o=\detokenize\expandafter{\@mltext}}
\tagmcbegin{tag=Span}
#1}{\tagstructbegin{tag=P,alttext-o=\detokenize\expandafter{\@mltext}}
\tagmcbegin{tag=P}
#1}
}

\renewenvironment{align}{%
\tagpdfifluatexT{  \ifmathmlopt \directlua{
						eqn_type_selector="m"
                                                   } \fi }
  \collect@body\wrapml\auxiliaryspace
 \start@align\@ne\st@rredfalse\m@ne
}{%
  \math@cr \black@\totwidth@
  \egroup
  \@macronestedifalign
  \ignorespacesafterend
\CloseFormula
}

\renewenvironment{align*}{%
\tagpdfifluatexT{  \ifmathmlopt \directlua{
						eqn_type_selector="m"
                                                   } \fi }
  \collect@body\wrapmlstar\auxiliaryspace
  \start@align\@ne\st@rredtrue\m@ne
}{%
  \endalign
}

\renewenvironment{alignat}{%
\tagpdfifluatexT{  \ifmathmlopt \directlua{
						eqn_type_selector="m"
                                                   } \fi }
  \collect@body\wrapml\auxiliaryspace\auxiliaryspace
  \start@align\z@\st@rredfalse
}{%
  \endalign
}

\renewenvironment{alignat*}{%
\tagpdfifluatexT{  \ifmathmlopt \directlua{
						eqn_type_selector="m"
                                                   } \fi }   
  \collect@body\wrapmlstar\auxiliaryspace
  \start@align\z@\st@rredtrue
}{%
  \endalign
}

\renewenvironment{xalignat}{%
\tagpdfifluatexT{  \ifmathmlopt \directlua{
						eqn_type_selector="m"
                                                   } \fi }
  \collect@body\wrapmlalt\auxiliaryspace
  \start@align\@ne\st@rredfalse
}{%
  \endalign
}

\renewenvironment{xalignat*}{%
\tagpdfifluatexT{  \ifmathmlopt \directlua{
						eqn_type_selector="m"
                                                   } \fi }
  \collect@body\wrapmlstar\auxiliaryspace
  \start@align\@ne\st@rredtrue
}{%
  \endalign
}

\renewenvironment{xxalignat}{%
\tagpdfifluatexT{  \ifmathmlopt \directlua{
						eqn_type_selector="m"
                                                   } \fi }
  \collect@body\wrapmlalt\auxiliaryspace
  \start@align\tw@\st@rredfalse
}{%
  \endalign
}

\renewenvironment{flalign}{%
\tagpdfifluatexT{  \ifmathmlopt \directlua{
						eqn_type_selector="m"
                                                   } \fi }
  \collect@body\wrapml\auxiliaryspace
  \start@align\tw@\st@rredfalse\m@ne
}{%
  \endalign
}

\renewenvironment{flalign*}{%
\tagpdfifluatexT{  \ifmathmlopt \directlua{
						eqn_type_selector="m"
                                                   } \fi }
  \collect@body\wrapmlstar\auxiliaryspace
  \start@align\tw@\st@rredtrue\m@ne
}{%
  \endalign
}

\renewenvironment{gather}{%
\tagpdfifluatexT{  \ifmathmlopt \directlua{
						eqn_type_selector="m"
                                                   } \fi }
  \collect@body\wrapmlalt\auxiliaryspace\auxiliaryspace
  \start@gather\st@rredfalse
}{%
  \math@cr \black@\totwidth@ \egroup
  $$\ignorespacesafterend
  \CloseFormula
}
\renewenvironment{gather*}{%
\tagpdfifluatexT{  \ifmathmlopt \directlua{
						eqn_type_selector="m"
                                                   } \fi }
  \collect@body\wrapmlstar\auxiliaryspace\auxiliaryspace
  \start@gather\st@rredtrue
}{%
  \endgather
}

\renewenvironment{multline}{%
\tagpdfifluatexT{  \ifmathmlopt \directlua{
						eqn_type_selector="m"
                                                   } \fi }
  \collect@body\wrapmlalt\auxiliaryspace\auxiliaryspace
  \start@multline\st@rredfalse
}{%
%  \iftagsleft@ \@xp\lendmultline@ \else \@xp\rendmultline@ \fi
  \@macronestedifmultline
  \ignorespacesafterend
\CloseFormula
}
\renewenvironment{multline*}{
\tagpdfifluatexT{  \ifmathmlopt \directlua{
						eqn_type_selector="m"
                                                   } \fi }
    \collect@body\wrapmlstar\auxiliaryspace\auxiliaryspace
    \start@multline\st@rredtrue
}{
  \endmultline
}
\makeatother
\ExplSyntaxOff
%%%%
% end of tagpdf option code
%%%%
\else
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
% accsupp option code (default)   %
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%\def\messaggio{option accsupp} %debug

\RequirePackage{accsupp}
\RequirePackage{ifluatex}
%\RequirePackage{amsmath}
%\RequirePackage{amssymb}
%\RequirePackage{xstring}
\ifluatex  \pdfextension catalog{/Lang (en-US)}
  \RequirePackage{fontspec}
  \RequirePackage{luacode}
  \newfontface\zerowidthfont{freeserif}
\directlua{
require("axessibility.lua")
}
\else
\pdfcompresslevel=0
\pdfoptionpdfminorversion=6
\input{glyphtounicode}
\pdfgentounicode=1
\fi
\makeatletter

\newtoks\@mltext
\newtoks\@mltexttmp
\newcommand{\doreplacement}[1]{
\ifluatex
\directlua{
replace_dls_and_double_dls(#1)
}
\fi
}

\renewcommand*{\BeginAccSupp}[1]{%
  \begingroup
    \setkeys{ACCSUPP}{#1}%
    \edef\ACCSUPP@span{%
      /S/Span<<%
        \ifx\ACCSUPP@Lang\relax
        \else
          /Lang\ACCSUPP@Lang
        \fi
        \ifx\ACCSUPP@Alt\relax
        \else
          /Alt\ACCSUPP@Alt
        \fi
        \ifx\ACCSUPP@ActualText\relax
        \else
          /ActualText\ACCSUPP@ActualText
        \fi
        \ifx\ACCSUPP@E\relax
        \else
          /E\ACCSUPP@E
        \fi
      >>%
    }%
    \ACCSUPP@bdc
    \ACCSUPP@space
  \endgroup
}
\makeatother


\newcommand{\auxiliaryspace}{ }


\makeatletter
\long\def\wrap#1{
\BeginAccSupp{method=escape,ActualText=\detokenize\expandafter{#1}}
 #1
\EndAccSupp{}%
}
\makeatother

\makeatletter
\long\def\wrapml#1{
\def\@mltext{\detokenize\expandafter{#1}}
\def\@mltexttmp{}
\StrBehind[5]{\@mltext}{ }[\@mltexttmp]
\StrGobbleRight{\@mltexttmp}{1}[\@mltext]
%\mltext
%\StrBehind[2]{\@xp{\the\@mltext}}{ }[\@mltexttmp]
%\StrGobbleRight{\@xp{\the\@mltexttmp}}{1}[\@mltext]
%
\BeginAccSupp{method=escape,ActualText=\auxiliaryspace\@mltext}
 #1
\EndAccSupp{}%
}
\makeatother


\makeatletter
\renewenvironment{equation}{%
 \incr@eqnum
  \mathdisplay@push
  \st@rredfalse \global\@eqnswtrue
 \mathdisplay{equation}%
  \collect@body\wrap\auxiliaryspace}{%
  \endmathdisplay{equation}%
  \mathdisplay@pop
  \ignorespacesafterend
}
\makeatother


\makeatletter
\renewenvironment{equation*}{%
  \mathdisplay@push
  \st@rredtrue \global\@eqnswfalse
  \mathdisplay{equation*}%
  \collect@body\wrap\auxiliaryspace}{%
  \endmathdisplay{equation*}%
  \mathdisplay@pop
  \ignorespacesafterend
}
\makeatother


\makeatletter
\protected\def\[#1\]{\begin{equation*}#1\end{equation*}}
\makeatother

\makeatletter
\newenvironment{tempenv}{%
  \relax\ifmmode\@badmath\else$\fi%
 \collect@body\wrap}{%
  \relax\ifmmode\ifinner$\else\@badmath\fi\else \@badmath\fi}
\protected\def\(#1\){\begin{tempenv}#1\end{tempenv}}
\makeatother


\makeatletter

\renewenvironment{align}{%
  \collect@body\wrapml\auxiliaryspace
 \start@align\@ne\st@rredfalse\m@ne
}{%
  \math@cr \black@\totwidth@
  \egroup
  \@macronestedifalign
  \ignorespacesafterend
}

\renewenvironment{align*}{%
  \collect@body\wrapml\auxiliaryspace
  \start@align\@ne\st@rredtrue\m@ne
}{%
  \endalign
}

\renewenvironment{alignat}{%
  \collect@body\wrapml\auxiliaryspace
  \start@align\z@\st@rredfalse
}{%
  \endalign
}
\renewenvironment{alignat*}{%
  \collect@body\wrapml\auxiliaryspace
  \start@align\z@\st@rredtrue
}{%
  \endalign
}
\renewenvironment{xalignat}{%
  \collect@body\wrapml\auxiliaryspace
  \start@align\@ne\st@rredfalse
}{%
  \endalign
}
\renewenvironment{xalignat*}{%
  \collect@body\wrapml\auxiliaryspace
  \start@align\@ne\st@rredtrue
}{%
  \endalign
}
\renewenvironment{xxalignat}{%
  \collect@body\wrapml\auxiliaryspace
  \start@align\tw@\st@rredtrue
}{%
  \endalign
}
\renewenvironment{flalign}{%
  \collect@body\wrapml\auxiliaryspace
  \start@align\tw@\st@rredfalse\m@ne
}{%
  \endalign
}

\renewenvironment{flalign*}{%
  \collect@body\wrapml\auxiliaryspace
  \start@align\tw@\st@rredtrue\m@ne
}{%
  \endalign
}

\renewenvironment{gather}{%
  \collect@body\wrapml\auxiliaryspace\auxiliaryspace
  \start@gather\st@rredfalse
}{%
  \math@cr \black@\totwidth@ \egroup
  $$\ignorespacesafterend
}

\renewenvironment{gather*}{%
  \collect@body\wrapml\auxiliaryspace\auxiliaryspace
  \start@gather\st@rredtrue
}{%
  \endgather
}

\renewenvironment{multline}{%
  \collect@body\wrapml\auxiliaryspace\auxiliaryspace
  \start@multline\st@rredfalse
}{%
  %\iftagsleft@ \@xp\lendmultline@ \else \@xp\rendmultline@ \fi
  \@macronestedifmultline
  \ignorespacesafterend
}

\renewenvironment{multline*}{
  \collect@body\wrapml\auxiliaryspace\auxiliaryspace
  \start@multline\st@rredtrue
}{
  \endmultline
}

%%}
%%
\makeatother
%%%%
% end of accsupp option code
%%%%
\fi

\endinput
%%
%% End of file `axessibility.sty'.